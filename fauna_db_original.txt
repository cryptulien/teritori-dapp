-Create Indexes

CreateIndex({
  name: "getMultisig",
  source: Collection("Multisig"),
  terms: [
    { field: ["data", "address"]}
    { field: ["data", "chainId"]}
  ]
})

CreateIndex({
  name: "signature_transaction_by_transaction",
  source: Collection("Signature"),
  terms: [
    { field: ["data", "transaction"]}
  ]
})

CreateIndex({
  name: "transactionsByMultisigAddressAndType",
  source: Collection("Transaction"),
  terms: [
    { field: ["data", "multisig"]},
    { field: ["data", "type"]}
  ]
})

CreateIndex({
  name: "transactionsByMultisig",
  source: Collection("Transaction"),
  terms: [
    { field: ["data", "multisig"]}
  ]
})

CreateIndex({
  name: "user_wallet",
  source: Collection("UserWallet"),
  terms:[
  { field: ["data", "userAddress"]}
  { field: ["data", "chainId"]}
  ]
})

-completeTransaction
Query(
  Lambda(
    ["transactionId", "txHash", "updatedSequence"],
    Let(
      {
        updatedValue: Update(
          Select(
            "ref",
            Get(Ref(Collection("Transaction"), Var("transactionId")))
          ),
          { data: { txHash: Var("txHash") } }
        ),
        multisigRef: Select("multisig", Select("data", Var("updatedValue"))),
        transactions: Filter(
          Map(
            Paginate(
              Match(Index("transactionsByMultisig"), Var("multisigRef")),
              { size: 20000 }
            ),
            Lambda("doc", Get(Var("doc")))
          ),
          Lambda(
            "doc",
            Let(
              {
                docData: Select("data", Var("doc")),
                docHash: If(
                  ContainsField("txHash", Var("docData")),
                  Select("txHash", Var("docData")),
                  null
                )
              },
              Or(Equals(Var("docHash"), ""), IsNull(Var("docHash")))
            )
          )
        ),
        updateObsoluteTransaction: Foreach(
          Var("transactions"),
          Lambda(
            "doc",
            Let(
              {
                upSeq: Update(Select("ref", Var("doc")), {
                  data: { sequence: Var("updatedSequence") }
                }),
                rmvSign: Map(
                  Paginate(
                    Match(
                      Index("signature_transaction_by_transaction"),
                      Select("ref", Var("doc"))
                    )
                  ),
                  Lambda("X", Delete(Var("X")))
                )
              },
              null
            )
          )
        )
      },
      Var("updatedValue")
    )
  )
)

-createOrFindMultisig
Query(
  Lambda(
    ["address", "pubkeyJSON", "chainId", "userAddresses"],
    Let(
      {
        multisig: Match(Index("getMultisig"), [Var("address"), Var("chainId")])
      },
      If(
        Exists(Var("multisig")),
        Get(Var("multisig")),
        Create(Collection("Multisig"), {
          data: {
            address: Var("address"),
            pubkeyJSON: Var("pubkeyJSON"),
            chainId: Var("chainId"),
            userAddresses: Var("userAddresses")
          }
        })
      )
    )
  )
)

-getTransactionCountByMultisigId
Query(
  Lambda(
    ["multisigId", "types"],
    Let(
      {
        q: Map(
          Var("types"),
          Lambda(
            "type",
            Count(
              If(
                Or(Equals(Var("type"), ""), IsNull(Var("type"))),
                Match(
                  Index("transactionsByMultisig"),
                  Ref(Collection("Multisig"), Var("multisigId"))
                ),
                Match(Index("transactionsByMultisigAddressAndType"), [
                  Ref(Collection("Multisig"), Var("multisigId")),
                  Var("type")
                ])
              )
            )
          )
        )
      },
      Var("q")
    )
  )
)

-multisigByUserAddress
Query(
  Lambda(
    ["address", "chainId"],
    Let(
      {
        paginatedList: Filter(
          Map(
            Paginate(Match(Index("getMultisigByChainId"), [Var("chainId")])),
            Lambda("doc", Get(Var("doc")))
          ),
          Lambda(
            "doc2",
            Let(
              {
                data: Select("data", Var("doc2")),
                userAddr: Select("userAddresses", Var("data"))
              },
              ContainsValue(Var("address"), Var("userAddr"))
            )
          )
        )
      },
      Select("data", Var("paginatedList"))
    )
  )
)

-transactionsByMultisigId
Query(
  Lambda(
    ["multisigId", "type", "size", "after", "_"],
    Let(
      {
        q: If(
          Or(Equals(Var("type"), ""), IsNull(Var("type"))),
          Match(
            Index("transactionsByMultisig"),
            Ref(Collection("Multisig"), Var("multisigId"))
          ),
          Match(Index("transactionsByMultisigAddressAndType"), [
            Ref(Collection("Multisig"), Var("multisigId")),
            Var("type")
          ])
        )
      },
      Map(
        Paginate(Var("q"), {
          after: If(IsNull(Var("after")), [], Var("after")),
          size: Var("size")
        }),
        Lambda("doc", Get(Var("doc")))
      )
    )
  )
)

-transactionsByUserAddress
Query(
  Lambda(
    ["address", "type", "chainId", "size", "after", "_"],
    Let(
      {
        mulsigRefs: Select(
          "data",
          Filter(
            Paginate(Match(Index("getMultisigByChainId"), [Var("chainId")])),
            Lambda(
              "doc",
              ContainsValue(
                Var("address"),
                Select("userAddresses", Select("data", Get(Var("doc"))))
              )
            )
          )
        )
      },
      Let(
        {
          q: If(
            Or(Equals(Var("type"), ""), IsNull(Var("type"))),
            Map(
              Var("mulsigRefs"),
              Lambda(
                "muRef",
                Match(Index("transactionsByMultisig"), Var("muRef"))
              )
            ),
            Map(
              Var("mulsigRefs"),
              Lambda(
                "muRef",
                Match(Index("transactionsByMultisigAddressAndType"), [
                  Var("muRef"),
                  Var("type")
                ])
              )
            )
          )
        },
        Map(
          Paginate(Union(Var("q")), {
            after: If(IsNull(Var("after")), [], Var("after")),
            size: Var("size")
          }),
          Lambda("doc", Get(Var("doc")))
        )
      )
    )
  )
)

-getMultisigsByUser
Query(
  Lambda(
    ["userAddress", "chainId", "size", "after", "before"],
    Let(
      {
        match: Match(Index("user_wallet"), [
          Var("userAddress"),
          Var("chainId")
        ]),
        page: If(
          Equals(Var("before"), null),
          If(
            Equals(Var("after"), null),
            Paginate(Var("match"), { size: Var("size") }),
            Paginate(Var("match"), { after: Var("after"), size: Var("size") })
          ),
          Paginate(Var("match"), { before: Var("before"), size: Var("size") })
        )
      },
      Map(Var("page"), Lambda("X", Get(Var("X"))))
    )
  )
)
