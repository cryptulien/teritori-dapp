directive @embedded on OBJECT

directive @collection(name: String!) on OBJECT

directive @index(name: String!) on FIELD_DEFINITION

directive @resolver(
  name: String
  paginated: Boolean! = false
) on FIELD_DEFINITION

directive @relation(name: String) on FIELD_DEFINITION

directive @unique(index: String) on FIELD_DEFINITION

scalar Date

# 'Multisig' input values
input MultisigInput {
  chainId: String!
  name: String
  pubkeyJSON: String!
  userAddresses: [String!]!
  address: String!
}

type Mutation {
  # Partially updates an existing document in the collection of 'Multisig'. It only modifies the values that are specified in the arguments. During execution, it verifies that required fields are not set to 'null'.
  partialUpdateMultisig(
    # The 'Multisig' document's ID
    id: ID!

    # 'Multisig' input values
    data: PartialUpdateMultisigInput!
  ): Multisig

  # Update an existing document in the collection of 'Multisig'
  updateMultisig(
    # The 'Multisig' document's ID
    id: ID!

    # 'Multisig' input values
    data: MultisigInput!
  ): Multisig

  # Update an existing document in the collection of 'Signature'
  updateSignature(
    # The 'Signature' document's ID
    id: ID!

    # 'Signature' input values
    data: SignatureInput!
  ): Signature

  # Partially updates an existing document in the collection of 'Transaction'. It only modifies the values that are specified in the arguments. During execution, it verifies that required fields are not set to 'null'.
  partialUpdateTransaction(
    # The 'Transaction' document's ID
    id: ID!

    # 'Transaction' input values
    data: PartialUpdateTransactionInput!
  ): Transaction

  # Create a new document in the collection of 'Signature'
  createSignature(
    # 'Signature' input values
    data: SignatureInput!
  ): Signature!

  # Update an existing document in the collection of 'Transaction'
  updateTransaction(
    # The 'Transaction' document's ID
    id: ID!

    # 'Transaction' input values
    data: TransactionInput!
  ): Transaction

  # Create a new document in the collection of 'Transaction'
  createTransaction(
    # 'Transaction' input values
    data: TransactionInput!
  ): Transaction!

  # Partially updates an existing document in the collection of 'Signature'. It only modifies the values that are specified in the arguments. During execution, it verifies that required fields are not set to 'null'.
  partialUpdateSignature(
    # The 'Signature' document's ID
    id: ID!

    # 'Signature' input values
    data: PartialUpdateSignatureInput!
  ): Signature

  # Create a new document in the collection of 'Multisig'
  createMultisig(
    # 'Multisig' input values
    data: MultisigInput!
  ): Multisig!

  # Delete an existing document in the collection of 'Signature'
  deleteSignature(
    # The 'Signature' document's ID
    id: ID!
  ): Signature

  # Delete an existing document in the collection of 'Multisig'
  deleteMultisig(
    # The 'Multisig' document's ID
    id: ID!
  ): Multisig

  # Delete an existing document in the collection of 'Transaction'
  deleteTransaction(
    # The 'Transaction' document's ID
    id: ID!
  ): Transaction
}

# 'Multisig' input values
input PartialUpdateMultisigInput {
  chainId: String
  name: String
  pubkeyJSON: String
  userAddresses: [String!]
  address: String
}

# 'Signature' input values
input PartialUpdateSignatureInput {
  bodyBytes: String
  signature: String
  address: String
  transaction: SignatureTransactionRelation
}

# 'Transaction' input values
input PartialUpdateTransactionInput {
  txHash: String
  signatures: [ID!]
  multisig: TransactionMultisigRelation
  sequence: Int
  decliners: [String!]
  createdAt: Time
  createdBy: String
  accountNumber: Int
  msgs: String
  memo: String
  fee: String
}

# 'TransactionsCounts' input values
input PartialUpdateTransactionsCountsInput {
  total: Int
  executed: Int
}

# 'Signature' input values
input SignatureInput {
  bodyBytes: String!
  signature: String!
  address: String!
  transaction: SignatureTransactionRelation
}

# Allow manipulating the relationship between the types 'Signature' and 'Transaction' using the field 'Signature.transaction'.
input SignatureTransactionRelation {
  # Create a document of type 'Transaction' and associate it with the current document.
  create: TransactionInput

  # Connect a document of type 'Transaction' with the current document using its ID.
  connect: ID
}

# 'Transaction' input values
input TransactionInput {
  txHash: String
  signatures: [ID!]!
  multisig: TransactionMultisigRelation
  sequence: Int
  decliners: [String!]!
  createdAt: Time!
  createdBy: String
  accountNumber: Int
  msgs: String
  memo: String
  fee: String
}

# Allow manipulating the relationship between the types 'Transaction' and 'Multisig' using the field 'Transaction.multisig'.
input TransactionMultisigRelation {
  # Create a document of type 'Multisig' and associate it with the current document.
  create: MultisigInput

  # Connect a document of type 'Multisig' with the current document using its ID.
  connect: ID
}

# 'TransactionsCounts' input values
input TransactionsCountsInput {
  total: Int!
  executed: Int!
}

type Multisig {
  chainId: String!
  name: String
  pubkeyJSON: String!

  # The document's ID.
  _id: ID!
  userAddresses: [String!]!
  address: String!

  # The document's timestamp.
  _ts: Long!
}

type Query {
  getMultisigTransactionsCounts(
    chainId: String!
    address: String!
  ): TransactionsCounts!

  # Find a document from the collection of 'Transaction' by its id.
  findTransactionByID(
    # The 'Transaction' document's ID
    id: ID!
  ): Transaction

  # Find a document from the collection of 'Signature' by its id.
  findSignatureByID(
    # The 'Signature' document's ID
    id: ID!
  ): Signature
  getUserMultisigs(
    chainId: String!
    userAddress: String!
    size: Int!
    before: Time
  ): [Multisig!]!
  getUserTransactions(
    chainId: String!
    userAddress: String!
    size: Int!
    before: Time
  ): [Transaction!]!
  getMultisig(chainId: String!, address: String!): Multisig!
  getMultisigTransactions(
    chainId: String!
    multisigAddress: String!
    size: Int!
    before: Time
  ): [Transaction!]!

  # Find a document from the collection of 'Multisig' by its id.
  findMultisigByID(
    # The 'Multisig' document's ID
    id: ID!
  ): Multisig
}

type Signature {
  bodyBytes: String!

  # The document's ID.
  _id: ID!
  signature: String!
  address: String!
  transaction: Transaction!

  # The document's timestamp.
  _ts: Long!
}

scalar Time

type Transaction {
  txHash: String
  signatures: [Signature!]!

  # The document's ID.
  _id: ID!
  multisig: Multisig!
  sequence: Int
  decliners: [String!]!
  createdAt: Time!
  createdBy: String
  accountNumber: Int
  msgs: String
  memo: String
  fee: String

  # The document's timestamp.
  _ts: Long!
}

type TransactionsCounts {
  total: Int!
  executed: Int!
}

# The `Long` scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1.
scalar Long
